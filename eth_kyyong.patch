diff --git a/arch/arm/boot/dts/amlogic/g12b_a311d_w400.dts b/arch/arm/boot/dts/amlogic/g12b_a311d_w400.dts
index 6b48feb..c0a0878 100644
--- a/arch/arm/boot/dts/amlogic/g12b_a311d_w400.dts
+++ b/arch/arm/boot/dts/amlogic/g12b_a311d_w400.dts
@@ -1357,6 +1357,7 @@
 	mc_val = <0x1621>;
 
 	internal_phy=<0>;
+	wol=<1>;
 };
 
 &uart_A {
diff --git a/arch/arm/boot/dts/amlogic/g12b_a311d_w400_a.dts b/arch/arm/boot/dts/amlogic/g12b_a311d_w400_a.dts
index 251cdef..d02f561 100644
--- a/arch/arm/boot/dts/amlogic/g12b_a311d_w400_a.dts
+++ b/arch/arm/boot/dts/amlogic/g12b_a311d_w400_a.dts
@@ -1336,6 +1336,7 @@
 	mc_val = <0x1621>;
 
 	internal_phy=<0>;
+	wol=<1>;
 };
 
 &uart_A {
diff --git a/drivers/amlogic/input/keyboard/gpio_keypad.c b/drivers/amlogic/input/keyboard/gpio_keypad.c
index 33abc17..9523f00 100644
--- a/drivers/amlogic/input/keyboard/gpio_keypad.c
+++ b/drivers/amlogic/input/keyboard/gpio_keypad.c
@@ -83,6 +83,7 @@ static void report_key_code(struct gpio_keypad *keypad, int gpio_val)
 	else {
 		key = keypad->current_key;
 		key->current_status = gpio_val;
+		pr_info("%s - %d : length = get_resume_method()==%d\n", __func__, __LINE__,key->current_status);
 		if (key->current_status) {
 			input_report_key(keypad->input_dev,
 				key->code, 0);
diff --git a/drivers/amlogic/input/remote/remote_meson.c b/drivers/amlogic/input/remote/remote_meson.c
index 43a360d..a502453 100644
--- a/drivers/amlogic/input/remote/remote_meson.c
+++ b/drivers/amlogic/input/remote/remote_meson.c
@@ -715,8 +715,9 @@ static int remote_resume(struct device *dev)
 	}
 	spin_unlock_irqrestore(&chip->slock, flags);
 
-#ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
-	if (get_resume_method() == REMOTE_WAKEUP) {
+	get_resume_method();
+	pr_info("%s - %d : length = get_resume_method()==%u\n", __func__, __LINE__,get_resume_method());
+	if (get_resume_method() == REMOTE_WAKEUP || get_resume_method() == ETH_PHY_GPIO_WAKEUP || get_resume_method() == ETH_PHY_WAKEUP_GPIO) {
 		input_event(chip->r_dev->input_device,
 		    EV_KEY, KEY_POWER, 1);
 		input_sync(chip->r_dev->input_device);
@@ -731,7 +732,6 @@ static int remote_resume(struct device *dev)
 		input_event(chip->r_dev->input_device, EV_KEY, 133, 0);
 		input_sync(chip->r_dev->input_device);
 	}
-#endif
 
 	irq_set_affinity(chip->irqno, cpumask_of(chip->irq_cpumask));
 	enable_irq(chip->irqno);
diff --git a/drivers/amlogic/usb/phy/phy-aml-new-usb2-v2.c b/drivers/amlogic/usb/phy/phy-aml-new-usb2-v2.c
index 96e4101..4c4352b 100644
--- a/drivers/amlogic/usb/phy/phy-aml-new-usb2-v2.c
+++ b/drivers/amlogic/usb/phy/phy-aml-new-usb2-v2.c
@@ -221,6 +221,7 @@ static int amlogic_new_usb2_init(struct usb_phy *x)
 
 static int amlogic_new_usb2_suspend(struct usb_phy *x, int suspend)
 {
+	pr_info("%s - %d : length = \n", __func__, __LINE__);
 	return 0;
 }
 
@@ -230,7 +231,7 @@ static void amlogic_new_usb2phy_shutdown(struct usb_phy *x)
 	u32 val;
 	u32 temp = 0;
 	u32 cnt = phy->portnum;
-
+	pr_info("%s - %d : length = \n", __func__, __LINE__);
 	while (cnt--)
 		temp = temp | (1 << (16 + cnt));
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
index d3073cd..9e0e02b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
@@ -28,7 +28,7 @@
 #include "stmmac_platform.h"
 
 #define ETHMAC_SPEED_10	BIT(1)
-
+#define DEBUG
 #ifdef CONFIG_AMLOGIC_ETH_PRIVE
 /*if not g12a use genphy driver*/
 /* if it's internal phy we will shutdown analog*/
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 31bc5a34..56b4a79 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -16,7 +16,6 @@
 #include <linux/phy.h>
 #include <linux/module.h>
 
-#ifdef CONFIG_AMLOGIC_ETH_PRIVE
 #include <linux/types.h>
 #include <linux/input.h>
 #include <linux/kernel.h>
@@ -24,7 +23,6 @@
 #include <linux/netdevice.h>
 
 #include <linux/amlogic/pm.h>
-#endif
 #define RTL821x_LCR		0x10
 #define RTL821x_PHYSR		0x11
 #define RTL821x_PHYSR_DUPLEX	0x2000
@@ -33,7 +31,7 @@
 #define RTL821x_INER_INIT	0x6400
 #define RTL821x_INSR		0x13
 #define RTL8211E_INER_LINK_STATUS 0x400
-
+#define DEBUG
 #define RTL8211F_INER_LINK_STATUS 0x0010
 #define RTL8211F_INSR		0x1d
 #define RTL8211F_PAGE_SELECT	0x1f
@@ -43,9 +41,7 @@
 MODULE_AUTHOR("Johnson Leung");
 MODULE_LICENSE("GPL");
 
-#ifdef CONFIG_AMLOGIC_ETH_PRIVE
-unsigned int support_external_phy_wol;
-#endif
+unsigned int support_external_phy_wol =1;
 static int rtl821x_ack_interrupt(struct phy_device *phydev)
 {
 	int err;
@@ -63,6 +59,7 @@ static int rtl8211f_ack_interrupt(struct phy_device *phydev)
 	err = phy_read(phydev, RTL8211F_INSR);
 	/* restore to default page 0 */
 	phy_write(phydev, RTL8211F_PAGE_SELECT, 0x0);
+	pr_info("not set wol mac:rtl8211f_ack_interrupt%u\n",support_external_phy_wol);
 
 	return (err < 0) ? err : 0;
 }
@@ -84,6 +81,7 @@ static int rtl8211e_config_intr(struct phy_device *phydev)
 {
 	int err;
 
+	pr_info("not set wol mac:rtl8211f_ack_interrupt%0x+++%0x\n",phydev->interrupts,PHY_INTERRUPT_ENABLED);
 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
 		err = phy_write(phydev, RTL821x_INER,
 				RTL8211E_INER_LINK_STATUS);
@@ -96,6 +94,7 @@ static int rtl8211e_config_intr(struct phy_device *phydev)
 static int rtl8211f_config_intr(struct phy_device *phydev)
 {
 	int err;
+	pr_info("not set wol mac:rtl8211f_ack_interrupt%0x+++%0x\n",phydev->interrupts,PHY_INTERRUPT_ENABLED);
 
 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
 		err = phy_write(phydev, RTL821x_INER,
@@ -111,9 +110,7 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	int ret;
 	u16 reg;
 
-#ifdef CONFIG_AMLOGIC_ETH_PRIVE
 	unsigned char *mac_addr = NULL;
-#endif
 	ret = genphy_config_init(phydev);
 	if (ret < 0)
 		return ret;
@@ -129,7 +126,6 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 		reg &= ~RTL8211F_TX_DELAY;
 
 	phy_write(phydev, 0x11, reg);
-#ifdef CONFIG_AMLOGIC_ETH_PRIVE
 	/*disable clk_out pin 35 set page 0x0a43 reg25.0 as 0*/
 	phy_write(phydev, RTL8211F_PAGE_SELECT, 0x0a43);
 	reg = phy_read(phydev, 0x19);
@@ -140,8 +136,11 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	/*reset phy to apply*/
 	reg = phy_write(phydev, 0x0, 0x9200);
 	/* config mac address for wol*/
+	pr_info("not set wol mac%u\n",support_external_phy_wol);
 	if ((phydev->attached_dev) && (support_external_phy_wol)) {
+		pr_info("not set wol maci::%u\n",support_external_phy_wol);
 		mac_addr = phydev->attached_dev->dev_addr;
+		pr_info("not set wol maci::%u++%0x%0x+%0x%0x+%0x%0x\n",support_external_phy_wol,mac_addr[0],(mac_addr[1] << 8),mac_addr[2],(mac_addr[3] << 8),mac_addr[4],(mac_addr[5] << 8));
 		phy_write(phydev, RTL8211F_PAGE_SELECT, 0xd8c);
 		phy_write(phydev, 0x10, mac_addr[0] | (mac_addr[1] << 8));
 		phy_write(phydev, 0x11, mac_addr[2] | (mac_addr[3] << 8));
@@ -149,7 +148,6 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	} else {
 		pr_debug("not set wol mac\n");
 	}
-#endif
 	phy_write(phydev, RTL8211F_PAGE_SELECT, 0xd04); /*set page 0xd04*/
 	phy_write(phydev, RTL821x_LCR, 0XC171); /*led configuration*/
 
@@ -159,12 +157,13 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	return 0;
 }
 
-#ifdef CONFIG_AMLOGIC_ETH_PRIVE
 int rtl8211f_suspend(struct phy_device *phydev)
 {
 	int value = 0;
 
+		pr_info("not set wol maci1::%u\n",support_external_phy_wol);
 	if (support_external_phy_wol) {
+		pr_info("not set wol maci2::%u\n",support_external_phy_wol);
 		mutex_lock(&phydev->lock);
 		phy_write(phydev, RTL8211F_PAGE_SELECT, 0xd8a);
 		/*set magic packet for wol*/
@@ -190,8 +189,11 @@ int rtl8211f_resume(struct phy_device *phydev)
 {
 	int value;
 
+
+		pr_info("not set wol maci3::%u\n",support_external_phy_wol);
 	if (support_external_phy_wol) {
 		mutex_lock(&phydev->lock);
+		pr_info("not set wol maci4::%u\n",support_external_phy_wol);
 
 		phy_write(phydev, RTL8211F_PAGE_SELECT, 0xd8a);
 		phy_write(phydev, 0x10, 0x0);
@@ -207,11 +209,11 @@ int rtl8211f_resume(struct phy_device *phydev)
 	} else {
 		genphy_resume(phydev);
 	}
+	
 	pr_debug("%s %d\n", __func__, __LINE__);
 
 	return 0;
 }
-#endif
 static struct phy_driver realtek_drvs[] = {
 	{
 		.phy_id         = 0x00008201,
@@ -266,13 +268,8 @@ int rtl8211f_resume(struct phy_device *phydev)
 		.read_status	= &genphy_read_status,
 		.ack_interrupt	= &rtl8211f_ack_interrupt,
 		.config_intr	= &rtl8211f_config_intr,
-#ifdef CONFIG_AMLOGIC_ETH_PRIVE
 		.suspend	= rtl8211f_suspend,
 		.resume		= rtl8211f_resume,
-#else
-		.suspend	= genphy_suspend,
-		.resume		= genphy_resume,
-#endif
 	},
 };
 
diff --git a/include/linux/amlogic/pm.h b/include/linux/amlogic/pm.h
index 2d71273..50b35ff 100644
--- a/include/linux/amlogic/pm.h
+++ b/include/linux/amlogic/pm.h
@@ -31,6 +31,8 @@
 #define	CEC_WAKEUP			8
 #define	REMOTE_CUS_WAKEUP		9
 #define ETH_PHY_WAKEUP      10
+#define ETH_PHY_WAKEUP_GPIO      12
+#define ETH_PHY_GPIO_WAKEUP 13
 extern unsigned int get_resume_method(void);
 extern unsigned int is_pm_freeze_mode(void);
 
