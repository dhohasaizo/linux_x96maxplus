commit 64a0d5972e2ba113c75bb86ed79e3c6e41eba985
Author: fk.luo <fk.luo@trigtop.com>
Date:   Fri Oct 11 18:07:32 2019 +0800

    fix screenshot can not get surfaceview content and video direct not currect when portrait mode

diff --git a/drivers/amlogic/media/video_processor/ppmgr/ppmgr_vpp.c b/drivers/amlogic/media/video_processor/ppmgr/ppmgr_vpp.c
old mode 100644
new mode 100755
index a0a4368..e4bdb60
--- a/drivers/amlogic/media/video_processor/ppmgr/ppmgr_vpp.c
+++ b/drivers/amlogic/media/video_processor/ppmgr/ppmgr_vpp.c
@@ -86,9 +86,9 @@
 #define RECEIVER_NAME "ppmgr"
 #define PROVIDER_NAME   "ppmgr"
 
-#define MM_ALLOC_SIZE SZ_16M
-#define MAX_WIDTH  960
-#define MAX_HEIGHT 736
+#define MM_ALLOC_SIZE (SZ_16M + SZ_32M)
+#define MAX_WIDTH 1080
+#define MAX_HEIGHT 1920
 #define THREAD_INTERRUPT 0
 #define THREAD_RUNNING 1
 #define INTERLACE_DROP_MODE 1
@@ -214,6 +214,8 @@ u32 index2canvas(u32 index)
 	return ppmgr_canvas_tab[index];
 }
 
+#define PPMGR2_CANVAS_INDEX_SRC (PPMGR_CANVAS_INDEX + 8)
+
 /* ***********************************************
  *
  *   ppmgr as a frame provider
@@ -713,34 +715,60 @@ static void vf_rotate_adjust(struct vframe_s *vf, struct vframe_s *new_vf,
 {
 	int w = 0, h = 0, disp_w = 0, disp_h = 0;
 	int scale_down_value = 1;
+	int input_height = 0, input_width = 0;
+	int interlace_mode = 0;
 #ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER_3D_PROCESS
 	scale_down_value = ppmgr_device.scale_down + 1;
 #endif
 	disp_w = ppmgr_device.disp_width / scale_down_value;
 	disp_h = ppmgr_device.disp_height / scale_down_value;
-
+	interlace_mode = vf->type & VIDTYPE_TYPEMASK;
+	if (vf->type & VIDTYPE_COMPRESS) {
+		input_width = vf->compWidth;
+		input_height = vf->compHeight;
+	} else {
+		input_width = vf->width;
+		if (interlace_mode &&
+			(vf->type & VIDTYPE_VIU_422))
+			input_height = vf->height * 2;
+		else
+			input_height = vf->height;
+	}
 	if (angle & 1) {
 		int ar = (vf->ratio_control
 			>> DISP_RATIO_ASPECT_RATIO_BIT) & 0x3ff;
 
-		/* h = min((int)vf->width, disp_h); */
-		h = min_t(int, vf->width, disp_h);
+		if (input_width > input_height) {
+			h = min_t(int, input_width, disp_h);
 
-		if (ar == 0)
-			w = vf->height * h / vf->width;
-		else
-			w = (ar * h) >> 8;
+			if (ar == 0 || ar == 0x3ff)
+				w = input_height * h / input_width;
+			else
+				w = (ar * h) >> 8;
 
-		if (w > disp_w) {
-			h = (h * disp_w) / w;
-			w = disp_w;
-		}
+			if (w > disp_w) {
+				h = (h * disp_w) / w;
+				w = disp_w;
+			}
+		} else {
+			w = min_t(int, input_height, disp_w);
 
+			if (ar == 0 || ar == 0x3ff)
+				h = input_width * w / input_height;
+			else
+				h = (w << 8) / ar;
+
+			if (h > disp_h) {
+				w = (w * disp_h) / h;
+				h = disp_h;
+			}
+		}
 		new_vf->ratio_control = DISP_RATIO_PORTRAIT_MODE;
 		new_vf->ratio_control |=
 				(h * 0x100 / w) << DISP_RATIO_ASPECT_RATIO_BIT;
 		/*set video aspect ratio*/
 	} else {
+
 		if ((vf->width < disp_w) && (vf->height < disp_h)) {
 			w = vf->width;
 			h = vf->height;
@@ -757,9 +785,9 @@ static void vf_rotate_adjust(struct vframe_s *vf, struct vframe_s *new_vf,
 		new_vf->ratio_control = vf->ratio_control;
 	}
 
-	if (h > 1080) {
-		w = w * 1080 / h;
-		h = 1080;
+    if (h > 1920) {
+        w = w * 1920 / h;
+        h = 1920;
 	}
 
 	new_vf->width = w;
@@ -1598,6 +1626,7 @@ static void process_vf_rotate(struct vframe_s *vf,
 	struct vframe_s *new_vf;
 	struct ppframe_s *pp_vf;
 	struct canvas_s cs0, cs1, cs2, cd;
+    struct vframe_s src_vf;
 	int ret = 0;
 	unsigned int cur_angle = 0;
 	int pic_struct = 0, interlace_mode;
@@ -1675,6 +1704,23 @@ static void process_vf_rotate(struct vframe_s *vf,
 		vfq_push(&q_ready, new_vf);
 		return;
 	}
+	if (vf->width > vf->height) {
+		if (cur_angle % 2) {
+			ppmgr_device.disp_width = MAX_WIDTH;
+			ppmgr_device.disp_height = MAX_HEIGHT;
+		} else {
+			ppmgr_device.disp_width = MAX_HEIGHT;
+			ppmgr_device.disp_height = MAX_WIDTH;
+		}
+	} else {
+		if (cur_angle % 2) {
+			ppmgr_device.disp_width = MAX_HEIGHT;
+			ppmgr_device.disp_height = MAX_WIDTH;
+		} else {
+			ppmgr_device.disp_width = MAX_HEIGHT;
+			ppmgr_device.disp_height = MAX_WIDTH;
+		}
+	}
 #ifdef CONFIG_AMLOGIC_POST_PROCESS_MANAGER_3D_PROCESS
 	platform_type = get_platform_type();
 	if (platform_type == PLATFORM_TV)
@@ -1873,18 +1919,62 @@ static void process_vf_rotate(struct vframe_s *vf,
 		ge2d_config->src1_gb_alpha = 0;/*0xff;*/
 		ge2d_config->dst_xy_swap = 0;
 
-		canvas_read(vf->canvas0Addr & 0xff, &cs0);
-		canvas_read((vf->canvas0Addr >> 8) & 0xff, &cs1);
-		canvas_read((vf->canvas0Addr >> 16) & 0xff, &cs2);
-		ge2d_config->src_planes[0].addr = cs0.addr;
-		ge2d_config->src_planes[0].w = cs0.width;
-		ge2d_config->src_planes[0].h = cs0.height;
-		ge2d_config->src_planes[1].addr = cs1.addr;
-		ge2d_config->src_planes[1].w = cs1.width;
-		ge2d_config->src_planes[1].h = cs1.height;
-		ge2d_config->src_planes[2].addr = cs2.addr;
-		ge2d_config->src_planes[2].w = cs2.width;
-		ge2d_config->src_planes[2].h = cs2.height;
+		src_vf = *vf;
+		if (vf->canvas0Addr == (u32)-1) {
+			canvas_config_config(PPMGR2_CANVAS_INDEX_SRC,
+						&src_vf.canvas0_config[0]);
+			canvas_config_config(PPMGR2_CANVAS_INDEX_SRC + 1,
+						&src_vf.canvas0_config[1]);
+			if (src_vf.plane_num == 2) {
+				src_vf.canvas0Addr =
+					(PPMGR2_CANVAS_INDEX_SRC)
+					| ((PPMGR2_CANVAS_INDEX_SRC + 1) << 8)
+					| ((PPMGR2_CANVAS_INDEX_SRC + 1) << 16);
+			} else if (src_vf.plane_num == 3) {
+				canvas_config_config(
+						PPMGR2_CANVAS_INDEX_SRC + 2,
+						&src_vf.canvas0_config[2]);
+				src_vf.canvas0Addr =
+					(PPMGR2_CANVAS_INDEX_SRC)
+					| ((PPMGR2_CANVAS_INDEX_SRC + 1) << 8)
+					| ((PPMGR2_CANVAS_INDEX_SRC + 2) << 16);
+			}
+
+			ge2d_config->src_planes[0].addr =
+					src_vf.canvas0_config[0].phy_addr;
+			ge2d_config->src_planes[0].w =
+					src_vf.canvas0_config[0].width;
+			ge2d_config->src_planes[0].h =
+					src_vf.canvas0_config[0].height;
+			ge2d_config->src_planes[1].addr =
+					src_vf.canvas0_config[1].phy_addr;
+			ge2d_config->src_planes[1].w =
+					src_vf.canvas0_config[1].width;
+			ge2d_config->src_planes[1].h =
+					src_vf.canvas0_config[1].height << 1;
+			if (src_vf.plane_num == 3) {
+				ge2d_config->src_planes[2].addr =
+					src_vf.canvas0_config[2].phy_addr;
+				ge2d_config->src_planes[2].w =
+					src_vf.canvas0_config[2].width;
+				ge2d_config->src_planes[2].h =
+					src_vf.canvas0_config[2].height << 1;
+			}
+		} else {
+			canvas_read(vf->canvas0Addr & 0xff, &cs0);
+			canvas_read((vf->canvas0Addr >> 8) & 0xff, &cs1);
+			canvas_read((vf->canvas0Addr >> 16) & 0xff, &cs2);
+			ge2d_config->src_planes[0].addr = cs0.addr;
+			ge2d_config->src_planes[0].w = cs0.width;
+			ge2d_config->src_planes[0].h = cs0.height;
+			ge2d_config->src_planes[1].addr = cs1.addr;
+			ge2d_config->src_planes[1].w = cs1.width;
+			ge2d_config->src_planes[1].h = cs1.height;
+			ge2d_config->src_planes[2].addr = cs2.addr;
+			ge2d_config->src_planes[2].w = cs2.width;
+			ge2d_config->src_planes[2].h = cs2.height;
+		}
+
 
 		canvas_read(new_vf->canvas0Addr & 0xff, &cd);
 		ge2d_config->dst_planes[0].addr = cd.addr;
@@ -2017,20 +2107,64 @@ static void process_vf_rotate(struct vframe_s *vf,
 		}
 
 	} else {
+		src_vf = *vf;
+		if (vf->canvas0Addr == (u32)-1) {
+			canvas_config_config(PPMGR2_CANVAS_INDEX_SRC,
+						&src_vf.canvas0_config[0]);
+			canvas_config_config(PPMGR2_CANVAS_INDEX_SRC + 1,
+						&src_vf.canvas0_config[1]);
+			if (src_vf.plane_num == 2) {
+				src_vf.canvas0Addr =
+					(PPMGR2_CANVAS_INDEX_SRC)
+					| ((PPMGR2_CANVAS_INDEX_SRC + 1) << 8)
+					| ((PPMGR2_CANVAS_INDEX_SRC + 1) << 16);
+			} else if (src_vf.plane_num == 3) {
+				canvas_config_config(
+						PPMGR2_CANVAS_INDEX_SRC + 2,
+						&src_vf.canvas0_config[2]);
+				src_vf.canvas0Addr =
+					(PPMGR2_CANVAS_INDEX_SRC)
+					| ((PPMGR2_CANVAS_INDEX_SRC + 1) << 8)
+					| ((PPMGR2_CANVAS_INDEX_SRC + 2) << 16);
+			}
+			ge2d_config->src_planes[0].addr =
+					src_vf.canvas0_config[0].phy_addr;
+			ge2d_config->src_planes[0].w =
+					src_vf.canvas0_config[0].width;
+			ge2d_config->src_planes[0].h =
+					src_vf.canvas0_config[0].height;
+			ge2d_config->src_planes[1].addr =
+					src_vf.canvas0_config[1].phy_addr;
+			ge2d_config->src_planes[1].w =
+					src_vf.canvas0_config[1].width;
+			ge2d_config->src_planes[1].h =
+					src_vf.canvas0_config[1].height << 1;
+			if (src_vf.plane_num == 3) {
+				ge2d_config->src_planes[2].addr =
+					src_vf.canvas0_config[2].phy_addr;
+				ge2d_config->src_planes[2].w =
+					src_vf.canvas0_config[2].width;
+				ge2d_config->src_planes[2].h =
+					src_vf.canvas0_config[2].height << 1;
+			}
+			ge2d_config->src_para.canvas_index = src_vf.canvas0Addr;
+		} else {
+			canvas_read(vf->canvas0Addr & 0xff, &cs0);
+			canvas_read((vf->canvas0Addr >> 8) & 0xff, &cs1);
+			canvas_read((vf->canvas0Addr >> 16) & 0xff, &cs2);
+			ge2d_config->src_planes[0].addr = cs0.addr;
+			ge2d_config->src_planes[0].w = cs0.width;
+			ge2d_config->src_planes[0].h = cs0.height;
+			ge2d_config->src_planes[1].addr = cs1.addr;
+			ge2d_config->src_planes[1].w = cs1.width;
+			ge2d_config->src_planes[1].h = cs1.height;
+			ge2d_config->src_planes[2].addr = cs2.addr;
+			ge2d_config->src_planes[2].w = cs2.width;
+			ge2d_config->src_planes[2].h = cs2.height;
+			ge2d_config->src_para.canvas_index = vf->canvas0Addr;
+		}
+
 
-		canvas_read(vf->canvas0Addr & 0xff, &cs0);
-		canvas_read((vf->canvas0Addr >> 8) & 0xff, &cs1);
-		canvas_read((vf->canvas0Addr >> 16) & 0xff, &cs2);
-		ge2d_config->src_planes[0].addr = cs0.addr;
-		ge2d_config->src_planes[0].w = cs0.width;
-		ge2d_config->src_planes[0].h = cs0.height;
-		ge2d_config->src_planes[1].addr = cs1.addr;
-		ge2d_config->src_planes[1].w = cs1.width;
-		ge2d_config->src_planes[1].h = cs1.height;
-		ge2d_config->src_planes[2].addr = cs2.addr;
-		ge2d_config->src_planes[2].w = cs2.width;
-		ge2d_config->src_planes[2].h = cs2.height;
-		ge2d_config->src_para.canvas_index = vf->canvas0Addr;
 		ge2d_config->src_para.format = get_input_format(vf);
 	}
 	ge2d_config->src_para.fill_color_en = 0;
@@ -3331,7 +3465,7 @@ int ppmgr_buffer_init(int vout_mode)
 	u32 decbuf_size;
 	unsigned int buf_start;
 	int buf_size;
-	struct vinfo_s vinfo = {.width = 1280, .height = 720, };
+	struct vinfo_s vinfo = {.width = 1080, .height = 1920, };
 	/* int flags = CODEC_MM_FLAGS_DMA; */
 	int flags = CODEC_MM_FLAGS_DMA | CODEC_MM_FLAGS_CMA_CLEAR;
 #ifdef INTERLACE_DROP_MODE
@@ -3443,6 +3577,7 @@ int ppmgr_buffer_init(int vout_mode)
 				ppmgr_device.disp_width = MAX_WIDTH;
 		}
 
+		//ppmgr_device.vinfo = &vinfo;
 		if (ppmgr_device.disp_height == 0) {
 			if (ppmgr_device.vinfo->height <= MAX_HEIGHT)
 				ppmgr_device.disp_height =
diff --git a/include/linux/amlogic/media/canvas/canvas.h b/include/linux/amlogic/media/canvas/canvas.h
index 98de6f3..1a3d31c 100644
--- a/include/linux/amlogic/media/canvas/canvas.h
+++ b/include/linux/amlogic/media/canvas/canvas.h
@@ -68,7 +68,7 @@ struct canvas_config_s {
  */
 #define AMVDEC_CANVAS_MAX1        0xbf
 #define AMVDEC_CANVAS_MAX2        0x25
-#define AMVDEC_CANVAS_START_INDEX 0x78
+#define AMVDEC_CANVAS_START_INDEX 0x80
 
 extern void canvas_config_config(u32 index, struct canvas_config_s *cfg);
 
