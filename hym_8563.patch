commit 250731adc8d590c12ed4118997d5c0a71a4bda72
Author: fk.luo <fk.luo@trigtop.com>
Date:   Mon Apr 22 10:02:47 2019 +0800

    add rtc-hym8563

diff --git a/arch/arm/boot/dts/amlogic/g12b_a311d_w400_a.dts b/arch/arm/boot/dts/amlogic/g12b_a311d_w400_a.dts
index 44fc409..5ab7bfc 100644
--- a/arch/arm/boot/dts/amlogic/g12b_a311d_w400_a.dts
+++ b/arch/arm/boot/dts/amlogic/g12b_a311d_w400_a.dts
@@ -871,7 +871,6 @@
 		max-touch-number = <10>;
 	};
 };
-
 &i2c3 {
 	status = "okay";
 	pinctrl-names="default";
@@ -894,7 +893,13 @@
 		differential_pair = <1>;
 		status = "disabled";
 	};
-
+       hym8563: hym8563@51 {
+                compatible = "haoyu,hym8563";
+                 reg = <0x51>;
+                 i2c_bus = "i2c_bus_c";
+                 #clock-cells = <0>;
+                 status = "okay";
+	  };
 	bl_extern_i2c {
 		compatible = "bl_extern, i2c";
 		dev_name = "lp8556";
diff --git a/arch/arm/configs/meson64_a32_defconfig b/arch/arm/configs/meson64_a32_defconfig
index 0590959..4c584ba 100644
--- a/arch/arm/configs/meson64_a32_defconfig
+++ b/arch/arm/configs/meson64_a32_defconfig
@@ -340,6 +340,7 @@ CONFIG_AMLOGIC_DTV_DEMOD=y
 CONFIG_AMLOGIC_MMC=y
 CONFIG_AMLOGIC_NAND=y
 CONFIG_AMLOGIC_VRTC=y
+CONFIG_RTC_DRV_HYM8563=y
 CONFIG_AMLOGIC_SMARTCARD=y
 CONFIG_AMLOGIC_CEC=y
 CONFIG_AMLOGIC_UNIFYKEY=y
diff --git a/drivers/rtc/rtc-hym8563.c b/drivers/rtc/rtc-hym8563.c
index e5ad527..8fae80b 100644
--- a/drivers/rtc/rtc-hym8563.c
+++ b/drivers/rtc/rtc-hym8563.c
@@ -128,9 +128,6 @@ static int hym8563_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	u8 buf[7];
 	int ret;
 
-	/* Years >= 2100 are to far in the future, 19XX is to early */
-	if (tm->tm_year < 100 || tm->tm_year >= 200)
-		return -EINVAL;
 
 	buf[0] = bin2bcd(tm->tm_sec);
 	buf[1] = bin2bcd(tm->tm_min);
@@ -168,121 +165,10 @@ static int hym8563_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	return 0;
 }
 
-static int hym8563_rtc_alarm_irq_enable(struct device *dev,
-					unsigned int enabled)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	int data;
-
-	data = i2c_smbus_read_byte_data(client, HYM8563_CTL2);
-	if (data < 0)
-		return data;
-
-	if (enabled)
-		data |= HYM8563_CTL2_AIE;
-	else
-		data &= ~HYM8563_CTL2_AIE;
-
-	return i2c_smbus_write_byte_data(client, HYM8563_CTL2, data);
-};
-
-static int hym8563_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct rtc_time *alm_tm = &alm->time;
-	u8 buf[4];
-	int ret;
-
-	ret = i2c_smbus_read_i2c_block_data(client, HYM8563_ALM_MIN, 4, buf);
-	if (ret < 0)
-		return ret;
-
-	/* The alarm only has a minute accuracy */
-	alm_tm->tm_sec = 0;
-
-	alm_tm->tm_min = (buf[0] & HYM8563_ALM_BIT_DISABLE) ?
-					-1 :
-					bcd2bin(buf[0] & HYM8563_MIN_MASK);
-	alm_tm->tm_hour = (buf[1] & HYM8563_ALM_BIT_DISABLE) ?
-					-1 :
-					bcd2bin(buf[1] & HYM8563_HOUR_MASK);
-	alm_tm->tm_mday = (buf[2] & HYM8563_ALM_BIT_DISABLE) ?
-					-1 :
-					bcd2bin(buf[2] & HYM8563_DAY_MASK);
-	alm_tm->tm_wday = (buf[3] & HYM8563_ALM_BIT_DISABLE) ?
-					-1 :
-					bcd2bin(buf[3] & HYM8563_WEEKDAY_MASK);
-
-	ret = i2c_smbus_read_byte_data(client, HYM8563_CTL2);
-	if (ret < 0)
-		return ret;
-
-	if (ret & HYM8563_CTL2_AIE)
-		alm->enabled = 1;
-
-	return 0;
-}
-
-static int hym8563_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct rtc_time *alm_tm = &alm->time;
-	u8 buf[4];
-	int ret;
-
-	/*
-	 * The alarm has no seconds so deal with it
-	 */
-	if (alm_tm->tm_sec) {
-		alm_tm->tm_sec = 0;
-		alm_tm->tm_min++;
-		if (alm_tm->tm_min >= 60) {
-			alm_tm->tm_min = 0;
-			alm_tm->tm_hour++;
-			if (alm_tm->tm_hour >= 24) {
-				alm_tm->tm_hour = 0;
-				alm_tm->tm_mday++;
-				if (alm_tm->tm_mday > 31)
-					alm_tm->tm_mday = 0;
-			}
-		}
-	}
-
-	ret = i2c_smbus_read_byte_data(client, HYM8563_CTL2);
-	if (ret < 0)
-		return ret;
-
-	ret &= ~HYM8563_CTL2_AIE;
-
-	ret = i2c_smbus_write_byte_data(client, HYM8563_CTL2, ret);
-	if (ret < 0)
-		return ret;
-
-	buf[0] = (alm_tm->tm_min < 60 && alm_tm->tm_min >= 0) ?
-			bin2bcd(alm_tm->tm_min) : HYM8563_ALM_BIT_DISABLE;
-
-	buf[1] = (alm_tm->tm_hour < 24 && alm_tm->tm_hour >= 0) ?
-			bin2bcd(alm_tm->tm_hour) : HYM8563_ALM_BIT_DISABLE;
-
-	buf[2] = (alm_tm->tm_mday <= 31 && alm_tm->tm_mday >= 1) ?
-			bin2bcd(alm_tm->tm_mday) : HYM8563_ALM_BIT_DISABLE;
-
-	buf[3] = (alm_tm->tm_wday < 7 && alm_tm->tm_wday >= 0) ?
-			bin2bcd(alm_tm->tm_wday) : HYM8563_ALM_BIT_DISABLE;
-
-	ret = i2c_smbus_write_i2c_block_data(client, HYM8563_ALM_MIN, 4, buf);
-	if (ret < 0)
-		return ret;
-
-	return hym8563_rtc_alarm_irq_enable(dev, alm->enabled);
-}
 
 static const struct rtc_class_ops hym8563_rtc_ops = {
 	.read_time		= hym8563_rtc_read_time,
 	.set_time		= hym8563_rtc_set_time,
-	.alarm_irq_enable	= hym8563_rtc_alarm_irq_enable,
-	.read_alarm		= hym8563_rtc_read_alarm,
-	.set_alarm		= hym8563_rtc_set_alarm,
 };
 
 /*
@@ -428,42 +314,6 @@ static struct clk *hym8563_clkout_register_clk(struct hym8563 *hym8563)
 }
 #endif
 
-/*
- * The alarm interrupt is implemented as a level-low interrupt in the
- * hym8563, while the timer interrupt uses a falling edge.
- * We don't use the timer at all, so the interrupt is requested to
- * use the level-low trigger.
- */
-static irqreturn_t hym8563_irq(int irq, void *dev_id)
-{
-	struct hym8563 *hym8563 = (struct hym8563 *)dev_id;
-	struct i2c_client *client = hym8563->client;
-	struct mutex *lock = &hym8563->rtc->ops_lock;
-	int data, ret;
-
-	mutex_lock(lock);
-
-	/* Clear the alarm flag */
-
-	data = i2c_smbus_read_byte_data(client, HYM8563_CTL2);
-	if (data < 0) {
-		dev_err(&client->dev, "%s: error reading i2c data %d\n",
-			__func__, data);
-		goto out;
-	}
-
-	data &= ~HYM8563_CTL2_AF;
-
-	ret = i2c_smbus_write_byte_data(client, HYM8563_CTL2, data);
-	if (ret < 0) {
-		dev_err(&client->dev, "%s: error writing i2c data %d\n",
-			__func__, ret);
-	}
-
-out:
-	mutex_unlock(lock);
-	return IRQ_HANDLED;
-}
 
 static int hym8563_init_device(struct i2c_client *client)
 {
@@ -497,16 +347,6 @@ static int hym8563_init_device(struct i2c_client *client)
 #ifdef CONFIG_PM_SLEEP
 static int hym8563_suspend(struct device *dev)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	int ret;
-
-	if (device_may_wakeup(dev)) {
-		ret = enable_irq_wake(client->irq);
-		if (ret) {
-			dev_err(dev, "enable_irq_wake failed, %d\n", ret);
-			return ret;
-		}
-	}
 
 	return 0;
 }
@@ -530,6 +370,16 @@ static int hym8563_probe(struct i2c_client *client,
 	struct hym8563 *hym8563;
 	int ret;
 
+      struct rtc_time tm_read, tm = {
+             .tm_sec = 0,
+            .tm_min = 0,
+             .tm_hour = 12,
+              .tm_mday = 1,
+              .tm_mon = 0,
+              .tm_year = 111,
+              .tm_wday = 6,
+
+	};
 	hym8563 = devm_kzalloc(&client->dev, sizeof(*hym8563), GFP_KERNEL);
 	if (!hym8563)
 		return -ENOMEM;
@@ -545,7 +395,7 @@ static int hym8563_probe(struct i2c_client *client,
 		return ret;
 	}
 
-	if (client->irq > 0) {
+	/*if (client->irq > 0) {
 		ret = devm_request_threaded_irq(&client->dev, client->irq,
 						NULL, hym8563_irq,
 						IRQF_TRIGGER_LOW | IRQF_ONESHOT,
@@ -555,7 +405,7 @@ static int hym8563_probe(struct i2c_client *client,
 				client->irq, ret);
 			return ret;
 		}
-	}
+	}*/
 
 	/* check state of calendar information */
 	ret = i2c_smbus_read_byte_data(client, HYM8563_SEC);
@@ -565,7 +415,21 @@ static int hym8563_probe(struct i2c_client *client,
 	hym8563->valid = !(ret & HYM8563_SEC_VL);
 	dev_dbg(&client->dev, "rtc information is %s\n",
 		hym8563->valid ? "valid" : "invalid");
+     if (!hym8563->valid) {
+              ret = hym8563_rtc_set_time(&client->dev, &tm);
+              if (ret < 0) {
+                       dev_err(&client->dev, "rtc set time failed, %d\n", ret);
+                       return ret;
 
+		}
+               hym8563->valid = true;
+		}
+      /* read current time */
+      ret = hym8563_rtc_read_time(&client->dev, &tm_read);
+      if (ret < 0) {
+              dev_err(&client->dev, "rtc read time failed, %d\n", ret);
+              return ret;
+		}
 	hym8563->rtc = devm_rtc_device_register(&client->dev, client->name,
 						&hym8563_rtc_ops, THIS_MODULE);
 	if (IS_ERR(hym8563->rtc))
