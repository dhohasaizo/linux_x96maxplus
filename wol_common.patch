diff --git a/drivers/amlogic/input/remote/remote_main.c b/drivers/amlogic/input/remote/remote_main.c
index 0a723e1..23e34c8 100755
--- a/drivers/amlogic/input/remote/remote_main.c
+++ b/drivers/amlogic/input/remote/remote_main.c
@@ -898,7 +898,8 @@ static int remote_resume(struct platform_device *pdev)
 			aml_write_aobus(AO_RTI_STATUS_REG2, 0);
 		}
 	} else {
-		if (get_resume_method() == REMOTE_WAKEUP) {
+                 get_resume_method();
+	if (get_resume_method()== REMOTE_WAKEUP || get_resume_method() == ETH_PHY_GPIO_WAKEUP) {
 			input_dbg("remote_wakeup\n");
 			input_event(gp_remote->input, EV_KEY, KEY_POWER, 1);
 			input_sync(gp_remote->input);
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 6db788d..6ae0ba9 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -15,7 +15,13 @@
  */
 #include <linux/phy.h>
 #include <linux/module.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
 
+#include <linux/amlogic/pm.h>
 #define RTL821x_PHYSR		0x11
 #define RTL821x_PHYSR_DUPLEX	0x2000
 #define RTL821x_PHYSR_SPEED	0xc000
@@ -29,8 +35,11 @@
 #define RTL821x_EPAGSR		0x1f
 #define RTL821x_LCR		    0x10
 
-#define	RTL8211E_INER_LINK_STATUS	0x400
-
+#define RTL8211E_INER_LINK_STATUS 0x400
+#define RTL8211F_INER_LINK_STATUS 0x0010
+#define RTL8211F_INSR		0x1d
+#define RTL8211F_PAGE_SELECT	0x1f
+#define RTL8211F_TX_DELAY	0x100
 MODULE_DESCRIPTION("Realtek PHY driver");
 MODULE_AUTHOR("Johnson Leung");
 MODULE_LICENSE("GPL");
@@ -39,7 +48,7 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 {
 	int val;
 	int bmcr = 0;
-
+        unsigned char *mac_addr;
 	/* close CLOCK output */
 	val = phy_read(phydev, RTL821x_PHYCR2);
 	if (val < 0)
@@ -71,7 +80,16 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	phy_write(phydev, RTL821x_EPAGSR, 0xd04); /*set page 0xd04*/
 	phy_write(phydev, RTL821x_LCR, 0XC171); /*led configuration*/
 	phy_write(phydev, RTL821x_EPAGSR, 0x0);
+       /* config mac address */
+	BUG_ON(phydev->attached_dev == NULL);
+	mac_addr = phydev->attached_dev->dev_addr;
+
+	phy_write(phydev, RTL8211F_PAGE_SELECT, 0xd8c);
+	phy_write(phydev, 0x10, mac_addr[0] | (mac_addr[1] << 8));
+	phy_write(phydev, 0x11, mac_addr[2] | (mac_addr[3] << 8));
+	phy_write(phydev, 0x12, mac_addr[4] | (mac_addr[5] << 8));
 
+	phy_write(phydev, RTL8211F_PAGE_SELECT, 0);
 	/* rx reg 21 bit 3 tx reg 17 bit 8*/
 	/* phy_write(phydev, 0x1f, 0xd08);
 	 * val =  phy_read(phydev, 0x15);
@@ -89,7 +107,17 @@ static int rtl821x_ack_interrupt(struct phy_device *phydev)
 
 	return (err < 0) ? err : 0;
 }
+static int rtl8211f_ack_interrupt(struct phy_device *phydev)
+{
+	int err;
 
+	phy_write(phydev, RTL8211F_PAGE_SELECT, 0xa43);
+	err = phy_read(phydev, RTL8211F_INSR);
+	/* restore to default page 0 */
+	phy_write(phydev, RTL8211F_PAGE_SELECT, 0x0);
+
+	return (err < 0) ? err : 0;
+}
 static int rtl8211b_config_intr(struct phy_device *phydev)
 {
 	int err;
@@ -115,7 +143,59 @@ static int rtl8211e_config_intr(struct phy_device *phydev)
 
 	return err;
 }
+static int rtl8211f_config_intr(struct phy_device *phydev)
+{
+	int err;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+		err = phy_write(phydev, RTL821x_INER,
+				RTL8211F_INER_LINK_STATUS);
+	else
+		err = phy_write(phydev, RTL821x_INER, 0);
+
+	return err;
+}
+int rtl8211f_suspend(struct phy_device *phydev)
+{
+	int value;
+
+	mutex_lock(&phydev->lock);
 
+	phy_write(phydev, RTL8211F_PAGE_SELECT, 0xd8a);
+	phy_write(phydev, 0x10, 0x1000);
+	phy_write(phydev, 0x11, 0x9fff);
+	phy_write(phydev, 0x13, 0x7);
+
+	phy_write(phydev, RTL8211F_PAGE_SELECT, 0xd40);
+
+	value = phy_read(phydev, 0x16);
+	phy_write(phydev, 0x16, value | (1 << 5));
+
+	phy_write(phydev, RTL8211F_PAGE_SELECT, 0);
+
+	mutex_unlock(&phydev->lock);
+
+	return 0;
+}
+int rtl8211f_resume(struct phy_device *phydev)
+{
+	int value;
+
+	mutex_lock(&phydev->lock);
+
+	phy_write(phydev, RTL8211F_PAGE_SELECT, 0xd8a);
+	phy_write(phydev, 0x10, 0x0);
+
+	value = phy_read(phydev, 0x11);
+	phy_write(phydev, 0x11, value & ~(0x1 << 15));
+
+	phy_write(phydev, RTL8211F_PAGE_SELECT, 0);
+	mutex_unlock(&phydev->lock);
+
+	pr_debug("%s %d\n", __func__, __LINE__);
+
+	return 0;
+}
 /* RTL8201CP */
 static struct phy_driver rtl8201cp_driver = {
 	.phy_id         = 0x00008201,
@@ -151,7 +231,7 @@ static struct phy_driver rtl8211e_driver = {
 	.flags		= PHY_HAS_INTERRUPT,
 	.config_aneg	= &genphy_config_aneg,
 	.read_status	= &genphy_read_status,
-	.ack_interrupt	= &rtl821x_ack_interrupt,
+        .ack_interrupt	= &rtl821x_ack_interrupt,
 	.config_intr	= &rtl8211e_config_intr,
 	.suspend	= genphy_suspend,
 	.resume		= genphy_resume,
@@ -169,8 +249,10 @@ static struct phy_driver rtl8211f_driver = {
 	.config_init	= rtl8211f_config_init,
 	.config_aneg	= &genphy_config_aneg,
 	.read_status	= &genphy_read_status,
-	.suspend	= genphy_suspend,
-	.resume		= genphy_resume,
+        .ack_interrupt	= rtl8211f_ack_interrupt,
+	.config_intr	= rtl8211f_config_intr,
+	.suspend	= rtl8211f_suspend,
+	.resume		= rtl8211f_resume,
 	.driver		= { .owner = THIS_MODULE,},
 };
 
diff --git a/include/linux/amlogic/pm.h b/include/linux/amlogic/pm.h
index ea3229a..b8eb6a1 100644
--- a/include/linux/amlogic/pm.h
+++ b/include/linux/amlogic/pm.h
@@ -12,6 +12,7 @@
 #define	CEC_WAKEUP			8
 #define	REMOTE_CUS_WAKEUP		9
 #define ETH_PHY_WAKEUP      10
+#define ETH_PHY_GPIO_WAKEUP 11
 #ifdef CONFIG_GXBB_SUSPEND
 unsigned int get_resume_method(void);
 #else
 

